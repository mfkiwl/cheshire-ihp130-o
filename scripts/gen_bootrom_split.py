#!/usr/bin/env python3
#
# Copyright 2022 ETH Zurich and University of Bologna.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0
#
# Nicole Narr <narrn@student.ethz.ch>
# Christopher Reinwardt <creinwar@student.ethz.ch>
#
# Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
# Florian Zaruba <zarubaf@iis.ee.ethz.ch>
# Stefan Mach <smach@iis.ee.ethz.ch>
# Thomas Benz <tbenz@iis.ee.ethz.ch>
# Paul Scheffler <paulsc@iis.ee.ethz.ch>
# Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>
# Gianna Paulin <pauling@iis.ee.ethz.ch>
# Tim Fischer <fischeti@iis.ee.ethz.ch>
# Philippe Sauter <phsauter@ethz.ch>

import os
import argparse
import math

# Parse arguments.
parser = argparse.ArgumentParser(description="Generate SystemVerilog bootrom")
parser.add_argument("BINARY",
                    help="Binary image for which to create a bootrom")
parser.add_argument(
    "--sv-module",
    "-m",
    metavar="BINARY",
    help=
    "Combinatorial SystemVerilog module with `reg_interface`. Name of the SystemVerilog module"
)
parser.add_argument(
    "-p",
    "--pad",
    action="store",
    default=0,
    type=int,
    help=
    "Pad to next power of two (if the value is not a power of two it is rounded appropriately)"
)

# natural power of two
def napot_type(value):
    val = int(value)
    if val & (val - 1) == 0 and val != 0:
        return val
    else:
        raise argparse.ArgumentTypeError("%s is not a power of two" % str(value))

parser.add_argument(
    "--num-parts",
    action="store",
    default=1,
    type=napot_type,
    help="Number of parts to split the bootrom into (default is 1, must be power of two)"
)
parser.add_argument("--arm-rom",
                    action="store_true",
                    help="Generate am Arm ROM code file.")
args = parser.parse_args()

# Read the bootrom binary.
with open(args.BINARY, "rb") as file:
    binary = file.read()

# Calculate length of bootrom.
# Fill up the binary with zeroes to the next power of two.
length = 8
while length < max(len(binary), args.pad):
    length *= 2

binary += b"\0" * (length - len(binary))


# Generate the words to be emitted.
def chunks(seq, size):
    return (seq[pos:pos + size] for pos in range(0, len(seq), size))


def format_word_bin(word):
    hex = ["{:08b}".format(int(x)) for x in word]
    return "".join(reversed(hex))


def format_word_hex(word):
    hex = ["{:02x}".format(int(x)) for x in word]
    hex += ["00"] * (4 - len(word))
    return "".join(reversed(hex))


def format_arm_rom(binary):
    words = list(enumerate(chunks(binary, 4)))
    return "\n".join(("{}".format(format_word_bin(x)) for i, x in words))


def format_binary(binary):
    words = list(enumerate(chunks(binary, 4)))
    num_words = len(words)
    return num_words, "\n                ".join(
        ("{:04}: data_o = 32'h{}; /* 0x{:04x} */".format(
            i, format_word_hex(x), i * 4) for i, x in words))


if args.arm_rom:
    words = format_arm_rom(binary)
    print(words)

if args.sv_module:
    num_words, words = format_binary(binary)

    # Emit the code.
    header = f'''
// Copyright 2022 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
// Florian Zaruba <zarubaf@iis.ee.ethz.ch>
// Stefan Mach <smach@iis.ee.ethz.ch>
// Thomas Benz <tbenz@iis.ee.ethz.ch>
// Paul Scheffler <paulsc@iis.ee.ethz.ch>
// Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>
// Philippe Sauter <phsauter@iis.ee.ethz.ch>
//
// AUTOMATICALLY GENERATED by {os.path.basename(__file__)} edit the script instead.
    '''.strip().format()

    if args.num_parts <= 1:
        # legacy all-in-one bootrom
        bootrom=f"""
module {args.sv_module} #(
    parameter int unsigned AddrWidth = 32,
    parameter int unsigned DataWidth = 32
)(
    input  logic                 clk_i,
    input  logic                 rst_ni,
    input  logic                 req_i,
    input  logic [AddrWidth-1:0] addr_i,
    output logic [DataWidth-1:0] data_o
);
    localparam unsigned NumWords = {num_words};
    logic [$clog2(NumWords)-1:0] word;

    assign word = addr_i / (DataWidth / 8);

    always_comb begin
        data_o = '0;
        unique case (word)
            {words}
            default: data_o = '0;
        endcase
    end

endmodule
        """
        print(header + bootrom)

    else:
        # new split bootrom
        num_parts = args.num_parts
        part_size = math.ceil(num_words / num_parts)
        remaining = num_words - part_size
        words     = words.split('\n')
        words[0]  = "                " + words[0]
        parts     = []
        for i in range(num_parts - 1):
            part = words[:part_size]
            parts.append({'data': ("\n".join(part)), 'size': len(part)})
            words = words[part_size:]
        parts.append({'data': ("\n".join(words)), 'size': len(words)})

        bootrom_part='''
module {module_name}_part{part_num} #(
    parameter int unsigned DataWidth = 32,

    localparam int unsigned PartNum = {part_num},
    localparam int unsigned NumWords = {num_words},
    localparam int unsigned NumWordAddrBits = $clog2(NumWords),
    localparam int unsigned NumSubwordAddrBits = $clog2(DataWidth / 8),
    localparam int unsigned AddrWidth = NumWordAddrBits + NumSubwordAddrBits
)(
    input  logic                 req_i,
    input  logic [AddrWidth-1:0] addr_i,
    output logic [DataWidth-1:0] data_o
);
    logic [NumWordAddrBits-1:0] word;

    assign word = addr_i[AddrWidth-1:NumSubwordAddrBits];

    always_comb begin
        data_o = '0;
        if (req_i) begin
            unique case ({{PartNum, word}})
{words}
                default: data_o = '0;
            endcase
        end
    end

endmodule
        '''

        bootrom_top='''
module {module_name}_split #(
    parameter int unsigned DataWidth = 32,
    parameter int unsigned AddrWidth = 32, // legacy

    localparam int unsigned NumWords = {num_words},
    localparam int unsigned NumWordAddrBits = $clog2(NumWords),
    localparam int unsigned NumSubwordAddrBits = $clog2(DataWidth / 8),
    // address width used in this module (rest is discarded)
    localparam int unsigned UsedAddrWidth = NumWordAddrBits + NumSubwordAddrBits
)(
    input  logic                 clk_i,  // not used, legacy compatibility
    input  logic                 rst_ni, // not used, legacy compatibility
    input  logic                 req_i,  // zero: bootrom output is silent ('0)
    input  logic [AddrWidth-1:0] addr_i,
    output logic [DataWidth-1:0] data_o
);
    // MSBs select between bootrom-parts
    localparam int unsigned NumParts = {num_parts};
    localparam int unsigned NumPartAddrBits = $clog2(NumParts);
    logic [NumPartAddrBits:0] part_sel;
    assign part_sel  = addr_i[UsedAddrWidth-1:UsedAddrWidth-NumPartAddrBits];

    // address size forwarded to each part
    logic [UsedAddrWidth-NumPartAddrBits-1:0] word_addr;
    assign word_addr = addr_i[UsedAddrWidth-NumPartAddrBits-1:0];

    logic [NumParts-1:0][DataWidth-1:0] part_data;
    logic [NumParts-1:0]                part_req;

    always_comb begin
        part_req = (1 << part_sel);
        data_o = '0;

        if(req_i)
            data_o = part_data[part_sel];
    end

    {inst_parts}

endmodule
        '''

        bootrom_inst_parts='''
    {module_name}_part{part_num} #(
        .DataWidth(DataWidth)
    ) i_part{part_num} (
        .req_i(part_req[{part_num}]),
        .addr_i(word_addr),
        .data_o(part_data[{part_num}])
    ); 
        '''

        bootrom_wrap='''
`ifndef NO_BOOTROM_WRAP
module {module_name} #(
    parameter int unsigned AddrWidth = 32,
    parameter int unsigned DataWidth = 32
)(
    input  logic                 clk_i,
    input  logic                 rst_ni,
    input  logic                 req_i,
    input  logic [AddrWidth-1:0] addr_i,
    output logic [DataWidth-1:0] data_o
);

    {module_name}_split #(
        .AddrWidth(AddrWidth),
        .DataWidth(DataWidth)
    ) i_bootrom_split (
        .clk_i (clk_i ),
        .rst_ni(rst_ni),
        .req_i (req_i ),
        .addr_i(addr_i),
        .data_o(data_o)
    );

endmodule
`endif
        '''

        bootrom = "\n"
        inst_parts = ""
        for i in range(num_parts):
            bootrom += bootrom_part.strip().format(
                            module_name=args.sv_module,
                            part_num=i,
                            num_words=parts[i]['size'],
                            words=parts[i]['data'],
                        )
            bootrom += "\n\n\n"

            inst_parts+= bootrom_inst_parts.strip().format(
                            module_name=args.sv_module,
                            part_num=i,
                        )
            inst_parts += "\n    "
        
        bootrom += bootrom_top.strip().format(
                        module_name=args.sv_module,
                        num_words=num_words,
                        num_parts=num_parts,
                        num_part_words=part_size,
                        inst_parts=inst_parts,
                    )
        bootrom += "\n\n\n"
        bootrom += bootrom_wrap.strip().format(
                        module_name=args.sv_module,
                    )
        print(header + bootrom)
